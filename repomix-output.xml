This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    deploy.yml
src/
  lib.rs
www/
  index.html
  index.js
.gitignore
Cargo.toml
LICENSE
pyproject.toml
README.md
template_setup.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/deploy.yml">
name: Deploy to GitHub Pages

on:
  # mainブランチにpushされたら実行
  push:
    branches: ["main"]
  # ブラウザから手動で実行したい時用
  workflow_dispatch:

permissions:
  contents: write # gh-pagesブランチへの書き込み権限

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Rust環境のセットアップ (キャッシュも効く現代的なAction)
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      # wasm-packのインストール
      - name: Install wasm-pack
        run: curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

      # ビルド実行 (Releaseモードで最適化)
      - name: Build WASM
        # ハイブリッド構成なので、Web用フラグ(--features wasm)を明示的にONにする
        run: wasm-pack build --target web --out-dir www/pkg --no-default-features --features wasm
      
      # CIサーバー上でのみ ルートと、pkg内部のgitignoreの両方を抹殺する。
      # これにより、ユーザーのローカル環境は汚さずに、生成された pkg フォルダを強制的に認識させる。
      - name: Remove .gitignore to allow deploying pkg
        run: |
          rm -f .gitignore
          rm -f www/pkg/.gitignore
      
      # Jekyll処理を無効化するファイルを作成
      - name: Create .nojekyll
        run: touch www/.nojekyll

      # GitHub Pagesへのデプロイ
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./www # このフォルダの中身を公開する
          force_orphan: true # 履歴を溜め込まず、常に最新版だけで上書きする（軽量化）

# ======================================================================================
#  [Reference] Python CI Job
#  将来的にPythonモジュールの自動テストが必要になった場合、以下のコメントを解除してjobsに追加してください。
#  (ローカルのUV環境で十分な場合は不要です)
# ======================================================================================
#   test-python:
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4
#
#       - name: Set up Python
#         uses: actions/setup-python@v5
#         with:
#           python-version: '3.10'
#
#       # Python側でもRustコンパイラは必要
#       - name: Install Rust
#         uses: dtolnay/rust-toolchain@stable
#
#       - name: Install Maturin
#         run: pip install maturin
#
#       - name: Build and Test Python Module
#         # Releaseビルドでテストする場合、--release を追加してください
#         run: |
#           maturin develop --features python
#           python -c "import nx_compute_rs; print(f'Test Result: {nx_compute_rs.compute_metrics(1000, 1.0)}')"
</file>

<file path="src/lib.rs">
use std::f64::consts::PI;

// Rayonのプレリュード（並列化用ツール）をインポート
#[cfg(not(target_family = "wasm"))]
use rayon::prelude::*;

/// Core Algorithm
/// use_parallel: trueなら並列化（Nativeのみ有効）、falseなら直列
fn core_algorithm(iterations: u64, param: f64, use_parallel: bool) -> f64 {
    // 【Native (Python) かつ Parallel ON の場合】
    #[cfg(not(target_family = "wasm"))]
    if use_parallel {
        return (0..iterations)
            .into_par_iter() // <--- ここが魔法！ par_iterにするだけ
            .map(|i| {
                let x = (i as f64) * PI / 180.0;
                (x * param).sin() * (x * param).cos()
            })
            .sum();
    }

    // 【WASM または Parallel OFF の場合】
    (0..iterations)
        .into_iter() // 通常のイテレータ
        .map(|i| {
            let x = (i as f64) * PI / 180.0;
            (x * param).sin() * (x * param).cos()
        })
        .sum()
}

// -----------------------------------------------------------------------------
// Module: Python Interface (PyO3)
// -----------------------------------------------------------------------------
#[cfg(feature = "python")]
use pyo3::prelude::*;

#[cfg(feature = "python")]
#[pyfunction]
// 引数に parallel を追加
fn compute_metrics(iterations: u64, param: f64, parallel: bool) -> PyResult<f64> {
    Ok(core_algorithm(iterations, param, parallel))
}

#[cfg(feature = "python")]
#[pymodule]
fn nx_compute_rs(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(compute_metrics, m)?)?;
    Ok(())
}

// -----------------------------------------------------------------------------
// Module: WebAssembly Interface (wasm-bindgen)
// -----------------------------------------------------------------------------
#[cfg(feature = "wasm")]
use wasm_bindgen::prelude::*;

#[cfg(feature = "wasm")]
#[wasm_bindgen]
// 引数に parallel を追加 (WASMでは内部で無視されるがIFは合わせる)
pub fn compute_metrics_js(iterations: u64, param: f64, parallel: bool) -> f64 {
    core_algorithm(iterations, param, parallel)
}
</file>

<file path="www/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nx-compute-rs Demo</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; line-height: 1.6; }
        h1 { border-bottom: 2px solid #eee; padding-bottom: 0.5rem; }
        .card { border: 1px solid #ddd; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        button { background-color: #0070f3; color: white; border: none; padding: 0.8rem 1.5rem; border-radius: 5px; cursor: pointer; font-size: 1rem; }
        button:hover { background-color: #005bb5; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #output { margin-top: 1rem; padding: 1rem; background: #f5f5f5; border-radius: 5px; font-family: monospace; }
    </style>
</head>
<body>
    <h1>nx-compute-rs</h1>
    <p>R&D Dual-Runtime Architecture Proof of Concept.</p>
    
    <div class="card">
        <h3>WebAssembly Computation</h3>
        <p>Run the rigorous Rust backend directly in your browser.</p>
        <button id="run-btn" disabled>Loading WASM...</button>
        <div id="output">Waiting for input...</div>
    </div>

    <script type="module" src="./index.js"></script>
</body>
</html>
</file>

<file path="www/index.js">
import init, { compute_metrics_js } from './pkg/nx_compute_rs.js';

async function run() {
    await init(); // Initialize WASM
    
    const btn = document.getElementById('run-btn');
    const output = document.getElementById('output');
    
    btn.innerText = "Run Core Algorithm (10M iters)";
    btn.disabled = false;

    btn.addEventListener('click', () => {
        output.innerText = "Computing...";
        
        // Use setTimeout to allow UI to update before blocking main thread
        setTimeout(() => {
            const start = performance.now();
            
            // Call Rust function
            const result = compute_metrics_js(10_000_000n, 1.5);
            
            const end = performance.now();
            output.innerText = `Result: ${result.toFixed(6)}\nTime: ${(end - start).toFixed(2)} ms`;
        }, 10);
    });
}

run();
</file>

<file path=".gitignore">
# ========================
# Rust / Cargo
# ========================
# ビルド生成物（巨大なので絶対にコミットしない）
/target/

# バックアップファイルなど
**/*.rs.bk

# Cargo.lock はライブラリ開発なら無視することもありますが、
# 今回はアプリケーション/PoCとしての再現性を重視するためコミットします。
# (無視したい場合は下の行の # を外してください)
# Cargo.lock

# ========================
# Python
# ========================
# バイトコード
__pycache__/
*.py[cod]
*$py.class

# C拡張モジュール (MaturinでビルドされたRustライブラリ本体)
*.so
*.pyd
*.dylib

# 配布用ビルドアーティファクト
dist/
build/
*.egg-info/

# 仮想環境 (uv venv)
.venv/
venv/
env/
ENV/

# テスト・型チェックキャッシュ
.pytest_cache/
.mypy_cache/

# ========================
# WebAssembly / Frontend
# ========================
# wasm-pack によって自動生成されるファイル群
# (ソースコードからいつでも再生成できるためコミット不要)
www/pkg/

# npm を使うようになった場合の依存ライブラリ
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# ========================
# OS / IDE / Editors
# ========================
# macOS
.DS_Store

# Windows
Thumbs.db
ehthumbs.db

# VS Code
.vscode/

# IntelliJ / PyCharm
.idea/

# Vim / Emacs
*~
*.swp
</file>

<file path="Cargo.toml">
[package]
name = "nx-compute-rs"
version = "0.1.0"
edition = "2021"
authors = ["R&D Researcher <your.email@example.com>"]
description = "A dual-runtime computation core for WebAssembly and Python, powered by Rust."

[lib]
name = "nx_compute_rs"
crate-type = ["cdylib"]

[features]
default = ["wasm"]
wasm = ["dep:wasm-bindgen"]
python = ["dep:pyo3"]

[dependencies]
# Common dependencies (Math, etc.)
serde = { version = "1.0", features = ["derive"] }

# Feature: WebAssembly
wasm-bindgen = { version = "0.2", optional = true }

# Feature: Python
pyo3 = { version = "0.20", features = ["extension-module"], optional = true }

rayon = "1.10"

[profile.release]
lto = true
opt-level = 3
codegen-units = 1
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Funmatu

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="pyproject.toml">
[build-system]
requires = ["maturin>=1.0,<2.0"]
build-backend = "maturin"

[project]
name = "nx_compute_rs"
requires-python = ">=3.8"
classifiers = [
    "Programming Language :: Rust",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]
dynamic = ["version"]
</file>

<file path="README.md">
# Nexus Compute RS: Dual-Runtime R&D Architecture

![Build Status](https://github.com/Funmatu/nx-compute-rs/actions/workflows/deploy.yml/badge.svg)
![Rust](https://img.shields.io/badge/Language-Rust-orange.svg)
![Platform](https://img.shields.io/badge/Platform-WASM%20%7C%20Python-blue.svg)

**Nexus Compute RS** is a rigorous proof-of-concept template designed for R&D in Physical AI and Robotics. It implements a "Write Once, Run Everywhere" strategy for high-performance algorithms, bridging the gap between web-based visualization/sharing and Python-based rigorous analysis/backend processing.

## 1. Architectural Philosophy

In modern R&D, we often face a dilemma:
* **Python** is required for data analysis, ML integration (PyTorch), and ROS2 interfacing.
* **Web (JavaScript)** is required for easy sharing, visualization, and zero-setup demos.
* **Performance** is critical for SLAM, Optimization, and Simulation.

This project solves this by implementing the core logic in **Rust**, which is then compiled into two distinct targets via Feature Flags:

```mermaid
graph TD
    subgraph "Core Logic (Rust)"
        Alg[Algorithm / Physics / Math]
    end

    subgraph "Target: Web (WASM)"
        WB[wasm-bindgen]
        JS[JavaScript / Browser]
        Alg --> WB --> JS
    end

    subgraph "Target: Python (Native)"
        PyO3[PyO3 Bindings]
        Py[Python Environment]
        Alg --> PyO3 --> Py
    end
```

## 2. Project Structure

```text
nx-compute-rs/
├── .github/workflows/   # CI/CD for automatic WASM deployment & Python testing
├── src/
│   └── lib.rs           # The SINGLE source of truth. Contains core logic + bindings.
├── www/                 # The Web Frontend (HTML/JS)
│   ├── index.html
│   ├── index.js
│   └── pkg/             # Generated WASM artifacts (by CI)
├── Cargo.toml           # Rust configuration (defines 'wasm' and 'python' features)
├── pyproject.toml       # Python build configuration (Maturin)
└── README.md            # This document
```

## 3. Usage Guide

### A. As a Python Library (For Analysis/Backend)

You can use the Rust core as a native Python extension. This provides near-C++ performance within your Python scripts.

**Prerequisites:**
* Rust toolchain (`rustup`)
* Python 3.8+
* `pip install maturin`

**Setup & Run:**
```bash
# 1. Build and install into current venv
maturin develop --release --features python

# 2. Run in Python
python -c "import nx_compute_rs; print(nx_compute_rs.compute_metrics(10000000, 1.5))"
# python -c "import numpy as np; i = np.arange(10000000); x = i * np.pi / 180.0 * 1.5; print(np.sum(np.sin(x) * np.cos(x)))"
# python -m timeit -s "import nx_compute_rs" "nx_compute_rs.compute_metrics(10000000, 1.5)"
# python -m timeit -s "import numpy as np" "i = np.arange(10000000); x = i * np.pi / 180.0 * 1.5; np.sum(np.sin(x) * np.cos(x))"
```

## Optional: Paralell vs Serial vs NumPy
```bash
python -c "
import nx_compute_rs
import numpy as np
import timeit

# 1. Rust Serial (直列)
t_serial = timeit.timeit(
    'nx_compute_rs.compute_metrics(10000000, 1.5, False)', 
    setup='import nx_compute_rs', 
    number=10
)

# 2. Rust Parallel (並列)
t_parallel = timeit.timeit(
    'nx_compute_rs.compute_metrics(10000000, 1.5, True)', 
    setup='import nx_compute_rs', 
    number=10
)

# 3. NumPy (ベクトル化)
t_numpy = timeit.timeit(
    'x = np.arange(10000000) * np.pi / 180.0 * 1.5; np.sum(np.sin(x) * np.cos(x))', 
    setup='import numpy as np', 
    number=10
)

print(f'Rust (Serial):   {t_serial/10*1000:.2f} ms')
print(f'Rust (Parallel): {t_parallel/10*1000:.2f} ms')
print(f'NumPy:           {t_numpy/10*1000:.2f} ms')
"
```

### B. As a Web Application (For Demo/Sharing)

You can run the same logic in the browser via WebAssembly.

**Prerequisites:**
* `wasm-pack` (`curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh`)

**Setup & Run:**
```bash
# 1. Build WASM blob
wasm-pack build --target web --out-dir www/pkg --no-default-features --features wasm

# 2. Serve locally (using Python's http server for simplicity)
cd www
python3 -m http.server 8000
# Open http://localhost:8000
```

## 4. Technical Details

### Feature Flags Strategy
We use `Cargo.toml` features to minimize binary size and dependencies.
* **`features = ["wasm"]`**: Includes `wasm-bindgen`. Generates `.wasm` binary. Panics happen in JS console.
* **`features = ["python"]`**: Includes `pyo3`. Generates `.so/.pyd` shared library. Python exception handling enabled.

### Performance Considerations
* **Zero-Cost Abstraction:** Rust's iterators and logic compile down to optimized machine code (simd instructions where applicable) for Python, and optimized bytecode for WASM.
* **Memory Safety:** No manual memory management (malloc/free) required, preventing segfaults in Python extensions.
* **GIL (Global Interpreter Lock):** The Rust code runs outside Python's GIL. For multi-threaded logic, Rust can utilize all CPU cores while Python is blocked, offering true parallelism.

## 5. Deployment

This repository uses **GitHub Actions** to automatically deploy the Web version.
1.  Push to `main`.
2.  Action triggers: Compiles Rust to WASM.
3.  Deploys `www/` folder to **GitHub Pages**.

## 6. Future Roadmap

* **GPU Acceleration:** Integrate `wgpu` for portable GPU compute shaders (WebGPU + Vulkan/Metal).
* **Serialization:** Add `serde` support to pass complex JSON/Structs between JS/Python and Rust.
* **Sim2Real:** Port the Python bindings directly to a ROS2 node.

---
*Author: Funmatu*
</file>

<file path="template_setup.py">
# template_setup.py
import os
import sys


def replace_in_file(filepath, old_kebab, new_kebab, old_snake, new_snake):
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            content = f.read()

        new_content = content.replace(old_kebab, new_kebab).replace(
            old_snake, new_snake
        )

        if content != new_content:
            with open(filepath, "w", encoding="utf-8") as f:
                f.write(new_content)
            print(f"Updated: {filepath}")
    except FileNotFoundError:
        print(f"Skipped (not found): {filepath}")


def main():
    if len(sys.argv) < 2:
        print("Usage: python template_setup.py <new-project-name>")
        print("Example: python template_setup.py my-robot-sim")
        return

    new_name_kebab = sys.argv[1]  # 例: my-robot-sim
    new_name_snake = new_name_kebab.replace("-", "_")  # 例: my_robot_sim

    # 現在のプロジェクト名（テンプレートの元名）
    OLD_NAME_KEBAB = "nx-compute-rs"
    OLD_NAME_SNAKE = "nx_compute_rs"

    # 書き換え対象のファイルリスト
    target_files = [
        "Cargo.toml",
        "pyproject.toml",
        "www/index.js",
        "www/index.html",
        ".github/workflows/deploy.yml",
    ]

    print(f"Renaming project from '{OLD_NAME_KEBAB}' to '{new_name_kebab}'...")

    for file in target_files:
        replace_in_file(
            file, OLD_NAME_KEBAB, new_name_kebab, OLD_NAME_SNAKE, new_name_snake
        )

    print("\nDone! Don't forget to run:")
    print(f"  rm template_setup.py")
    print(f"  git commit -am 'setup: initialize project {new_name_kebab}'")


if __name__ == "__main__":
    main()
</file>

</files>
