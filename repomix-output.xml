This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    deploy.yml
data/
  object_0.ply
src/
  lib.rs
  shader.wgsl
tests/
  debug_loaded.py
  test_gpu.py
  test_load.py
www/
  index.html
  index.js
.gitignore
Cargo.toml
LICENSE
pyproject.toml
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/shader.wgsl">
struct GaussianSplat {
    pos: vec3<f32>,
    opacity: f32,
    scale: vec3<f32>,
    _pad1: f32,
    rot: vec4<f32>,
    sh_dc: vec3<f32>,
    _pad2: f32,
};

struct Surfel {
    pos: vec3<f32>,
    color: vec3<f32>,
    normal: vec3<f32>,
    _pad: vec3<f32>,
};

struct CameraUniform {
    view_proj: mat4x4<f32>,
    camera_pos: vec3<f32>,
    _pad: f32, // <--- パディングを追加し、display_modeをオフセット80に配置
    display_mode: u32, // 0: RGB, 1: Normal
};

// --- Compute Shader ---

@group(0) @binding(0) var<storage, read> input_splats : array<GaussianSplat>;
@group(0) @binding(1) var<storage, read_write> output_surfels : array<Surfel>;

fn quat_to_mat3(q: vec4<f32>) -> mat3x3<f32> {
    let x = q.x; let y = q.y; let z = q.z; let w = q.w;
    let x2 = x*x; let y2 = y*y; let z2 = z*z;
    let xy = x*y; let xz = x*z; let yz = y*z;
    let wx = w*x; let wy = w*y; let wz = w*z;
    return mat3x3<f32>(
        vec3<f32>(1.0 - 2.0*(y2 + z2), 2.0*(xy + wz),       2.0*(xz - wy)),
        vec3<f32>(2.0*(xy - wz),       1.0 - 2.0*(x2 + z2), 2.0*(yz + wx)),
        vec3<f32>(2.0*(xz + wy),       2.0*(yz - wx),       1.0 - 2.0*(x2 + y2))
    );
}

@compute @workgroup_size(64)
fn compute_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    if (idx >= arrayLength(&input_splats)) { return; }

    let splat = input_splats[idx];

    // SH (DC) to Color
    // RGB = 0.5 + C0 * sh
    let C0 = 0.2820947917;
    var rgb = 0.5 + C0 * splat.sh_dc;
    rgb = clamp(rgb, vec3<f32>(0.0), vec3<f32>(1.0));

    // Normal Estimation
    let q = normalize(splat.rot);
    let R = quat_to_mat3(q);
    let s = abs(splat.scale);
    
    var local_n = vec3<f32>(0.0, 0.0, 1.0);
    if (s.x < s.y && s.x < s.z) { local_n = vec3<f32>(1.0, 0.0, 0.0); }
    else if (s.y < s.z) { local_n = vec3<f32>(0.0, 1.0, 0.0); }
    
    let normal = normalize(R * local_n);

    var out: Surfel;
    out.pos = splat.pos;
    out.color = rgb;
    out.normal = normal;
    out._pad = vec3<f32>(0.0);

    output_surfels[idx] = out;
}

// --- Render Shader ---

@group(0) @binding(0) var<uniform> camera: CameraUniform;

struct VertexInput {
    @location(0) pos: vec3<f32>,
    @location(1) color: vec3<f32>,
    @location(2) normal: vec3<f32>,
};

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) color: vec3<f32>,
};

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    out.clip_position = camera.view_proj * vec4<f32>(in.pos, 1.0);

    if (camera.display_mode == 0u) {
        out.color = in.color;
    } else {
        out.color = in.normal * 0.5 + 0.5;
    }
    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    return vec4<f32>(in.color, 1.0);
}
</file>

<file path="tests/debug_loaded.py">
import struct

filename = "data/object_0.ply"

with open(filename, "rb") as f:
    # 1. ヘッダーを読み飛ばす（end_headerを探す）
    content = b""
    while True:
        chunk = f.read(1)
        content += chunk
        if b"end_header" in content:
            # 改行コードの処理（\n または \r\n）
            char = f.read(1)
            if char == b"\r":
                f.read(1)  # \nをスキップ
            break

    print("--- Binary Header End ---")

    # 2. 最初の頂点のデータを読み込む
    # ヘッダーによると: x, y, z, nx, ny, nz, f_dc_0...rot_3 (合計17個のfloat)
    # float32 (4bytes) * 17 = 68 bytes

    data = f.read(68)
    if len(data) < 68:
        print("Error: Not enough data for one vertex")
        exit()

    # 3. float32 (Little Endian) として解釈
    # <f: Little Endian float
    values = struct.unpack("<17f", data)

    properties = [
        "x",
        "y",
        "z",
        "nx",
        "ny",
        "nz",
        "f_dc_0",
        "f_dc_1",
        "f_dc_2",
        "opacity",
        "scale_0",
        "scale_1",
        "scale_2",
        "rot_0",
        "rot_1",
        "rot_2",
        "rot_3",
    ]

    print(f"{'Property':<10} | {'Value':<20}")
    print("-" * 35)
    for name, val in zip(properties, values):
        print(f"{name:<10} | {val:.6f}")
</file>

<file path="tests/test_gpu.py">
import gs_slam_core
import time

ply_path = "data/object_0.ply"  # パスは適宜変更

print("1. Loading PLY...")
manager = gs_slam_core.SplatManager(ply_path)
print(f"Loaded {manager.count()} splats.")

print("2. Running GPU Compute...")
start = time.time()

# ここでGPUが火を吹きます
count = manager.compute_geometry()

elapsed = (time.time() - start) * 1000
print(f"Computed {count} surfels in {elapsed:.2f} ms")

print("3. Result Validation")
print(manager.debug_first_surfel())
</file>

<file path="tests/test_load.py">
import gs_slam_core
import time
import os

# Ensure you have a valid .ply file from a 3DGS training result
ply_file = "data/object_0.ply"

if not os.path.exists(ply_file):
    print(f"Please provide a valid path. File not found: {ply_file}")
    exit(1)

print(f"Loading {ply_file}...")
start_time = time.time()

# This triggers Rust mmap + parsing
manager = gs_slam_core.SplatManager(ply_file)

end_time = time.time()
elapsed = (end_time - start_time) * 1000

count = manager.count()
print(f"--------------------------------------------------")
print(f"Loaded {count:,} splats in {elapsed:.2f} ms")
print(f"Throughput: {count / (elapsed / 1000) / 1_000_000:.2f} M splats/sec")
print(f"First Splat Data: {manager.debug_first_splat()}")
print(f"--------------------------------------------------")
</file>

<file path=".gitignore">
# ========================
# Rust / Cargo
# ========================
# ビルド生成物（巨大なので絶対にコミットしない）
/target/

# バックアップファイルなど
**/*.rs.bk

# Cargo.lock はライブラリ開発なら無視することもありますが、
# 今回はアプリケーション/PoCとしての再現性を重視するためコミットします。
# (無視したい場合は下の行の # を外してください)
# Cargo.lock

# ========================
# Python
# ========================
# バイトコード
__pycache__/
*.py[cod]
*$py.class

# C拡張モジュール (MaturinでビルドされたRustライブラリ本体)
*.so
*.pyd
*.dylib

# 配布用ビルドアーティファクト
dist/
build/
*.egg-info/

# 仮想環境 (uv venv)
.venv/
venv/
env/
ENV/

# テスト・型チェックキャッシュ
.pytest_cache/
.mypy_cache/

# ========================
# WebAssembly / Frontend
# ========================
# wasm-pack によって自動生成されるファイル群
# (ソースコードからいつでも再生成できるためコミット不要)
www/pkg/

# npm を使うようになった場合の依存ライブラリ
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# ========================
# OS / IDE / Editors
# ========================
# macOS
.DS_Store

# Windows
Thumbs.db
ehthumbs.db

# VS Code
.vscode/

# IntelliJ / PyCharm
.idea/

# Vim / Emacs
*~
*.swp
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Funmatu

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="README.md">
# Nexus Compute RS: Dual-Runtime R&D Architecture

![Build Status](https://github.com/Funmatu/nx-compute-rs/actions/workflows/deploy.yml/badge.svg)
![Rust](https://img.shields.io/badge/Language-Rust-orange.svg)
![Platform](https://img.shields.io/badge/Platform-WASM%20%7C%20Python-blue.svg)

**Nexus Compute RS** is a rigorous proof-of-concept template designed for R&D in Physical AI and Robotics. It implements a "Write Once, Run Everywhere" strategy for high-performance algorithms, bridging the gap between web-based visualization/sharing and Python-based rigorous analysis/backend processing.

## 1. Architectural Philosophy

In modern R&D, we often face a dilemma:
* **Python** is required for data analysis, ML integration (PyTorch), and ROS2 interfacing.
* **Web (JavaScript)** is required for easy sharing, visualization, and zero-setup demos.
* **Performance** is critical for SLAM, Optimization, and Simulation.

This project solves this by implementing the core logic in **Rust**, which is then compiled into two distinct targets via Feature Flags:

```mermaid
graph TD
    subgraph "Core Logic (Rust)"
        Alg[Algorithm / Physics / Math]
    end

    subgraph "Target: Web (WASM)"
        WB[wasm-bindgen]
        JS[JavaScript / Browser]
        Alg --> WB --> JS
    end

    subgraph "Target: Python (Native)"
        PyO3[PyO3 Bindings]
        Py[Python Environment]
        Alg --> PyO3 --> Py
    end
```

## 2. Project Structure

```text
nx-compute-rs/
├── .github/workflows/   # CI/CD for automatic WASM deployment & Python testing
├── src/
│   └── lib.rs           # The SINGLE source of truth. Contains core logic + bindings.
├── www/                 # The Web Frontend (HTML/JS)
│   ├── index.html
│   ├── index.js
│   └── pkg/             # Generated WASM artifacts (by CI)
├── Cargo.toml           # Rust configuration (defines 'wasm' and 'python' features)
├── pyproject.toml       # Python build configuration (Maturin)
└── README.md            # This document
```

## 3. Usage Guide

### A. As a Python Library (For Analysis/Backend)

You can use the Rust core as a native Python extension. This provides near-C++ performance within your Python scripts.

**Prerequisites:**
* Rust toolchain (`rustup`)
* Python 3.8+
* `pip install maturin`

**Setup & Run:**
```bash
# 1. Build and install into current venv
maturin develop --release --features python

# 2. Run in Python
python -c "import nx_compute_rs; print(nx_compute_rs.compute_metrics(10000000, 1.5))"
# python -c "import numpy as np; i = np.arange(10000000); x = i * np.pi / 180.0 * 1.5; print(np.sum(np.sin(x) * np.cos(x)))"
# python -m timeit -s "import nx_compute_rs" "nx_compute_rs.compute_metrics(10000000, 1.5)"
# python -m timeit -s "import numpy as np" "i = np.arange(10000000); x = i * np.pi / 180.0 * 1.5; np.sum(np.sin(x) * np.cos(x))"
```

## Optional: Paralell vs Serial vs NumPy
```bash
python -c "
import nx_compute_rs
import numpy as np
import timeit

# 1. Rust Serial (直列)
t_serial = timeit.timeit(
    'nx_compute_rs.compute_metrics(10000000, 1.5, False)', 
    setup='import nx_compute_rs', 
    number=10
)

# 2. Rust Parallel (並列)
t_parallel = timeit.timeit(
    'nx_compute_rs.compute_metrics(10000000, 1.5, True)', 
    setup='import nx_compute_rs', 
    number=10
)

# 3. NumPy (ベクトル化)
t_numpy = timeit.timeit(
    'x = np.arange(10000000) * np.pi / 180.0 * 1.5; np.sum(np.sin(x) * np.cos(x))', 
    setup='import numpy as np', 
    number=10
)

print(f'Rust (Serial):   {t_serial/10*1000:.2f} ms')
print(f'Rust (Parallel): {t_parallel/10*1000:.2f} ms')
print(f'NumPy:           {t_numpy/10*1000:.2f} ms')
"
```

### B. As a Web Application (For Demo/Sharing)

You can run the same logic in the browser via WebAssembly.

**Prerequisites:**
* `wasm-pack` (`curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh`)

**Setup & Run:**
```bash
# 1. Build WASM blob
wasm-pack build --target web --out-dir www/pkg --no-default-features --features wasm

# 2. Serve locally (using Python's http server for simplicity)
cd www
python3 -m http.server 8000
# Open http://localhost:8000
```

## 4. Technical Details

### Feature Flags Strategy
We use `Cargo.toml` features to minimize binary size and dependencies.
* **`features = ["wasm"]`**: Includes `wasm-bindgen`. Generates `.wasm` binary. Panics happen in JS console.
* **`features = ["python"]`**: Includes `pyo3`. Generates `.so/.pyd` shared library. Python exception handling enabled.

### Performance Considerations
* **Zero-Cost Abstraction:** Rust's iterators and logic compile down to optimized machine code (simd instructions where applicable) for Python, and optimized bytecode for WASM.
* **Memory Safety:** No manual memory management (malloc/free) required, preventing segfaults in Python extensions.
* **GIL (Global Interpreter Lock):** The Rust code runs outside Python's GIL. For multi-threaded logic, Rust can utilize all CPU cores while Python is blocked, offering true parallelism.

## 5. Deployment

This repository uses **GitHub Actions** to automatically deploy the Web version.
1.  Push to `main`.
2.  Action triggers: Compiles Rust to WASM.
3.  Deploys `www/` folder to **GitHub Pages**.

## 6. Future Roadmap

* **GPU Acceleration:** Integrate `wgpu` for portable GPU compute shaders (WebGPU + Vulkan/Metal).
* **Serialization:** Add `serde` support to pass complex JSON/Structs between JS/Python and Rust.
* **Sim2Real:** Port the Python bindings directly to a ROS2 node.

---
*Author: Funmatu*
</file>

<file path=".github/workflows/deploy.yml">
name: Deploy to GitHub Pages

on:
  # mainブランチにpushされたら実行
  push:
    branches: ["main"]
  # ブラウザから手動で実行したい時用
  workflow_dispatch:

permissions:
  contents: write # gh-pagesブランチへの書き込み権限

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Rust環境のセットアップ (キャッシュも効く現代的なAction)
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      # wasm-packのインストール
      - name: Install wasm-pack
        run: curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

      # ビルド実行 (Releaseモードで最適化)
      - name: Build WASM
        # ハイブリッド構成なので、Web用フラグ(--features wasm)を明示的にONにする
        run: wasm-pack build --target web --out-dir www/pkg --no-default-features --features wasm
      
      # CIサーバー上でのみ ルートと、pkg内部のgitignoreの両方を抹殺する。
      # これにより、ユーザーのローカル環境は汚さずに、生成された pkg フォルダを強制的に認識させる。
      - name: Remove .gitignore to allow deploying pkg
        run: |
          rm -f .gitignore
          rm -f www/pkg/.gitignore
      
      # Jekyll処理を無効化するファイルを作成
      - name: Create .nojekyll
        run: touch www/.nojekyll

      # GitHub Pagesへのデプロイ
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./www # このフォルダの中身を公開する
          force_orphan: true # 履歴を溜め込まず、常に最新版だけで上書きする（軽量化）

# ======================================================================================
#  [Reference] Python CI Job
#  将来的にPythonモジュールの自動テストが必要になった場合、以下のコメントを解除してjobsに追加してください。
#  (ローカルのUV環境で十分な場合は不要です)
# ======================================================================================
#   test-python:
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4
#
#       - name: Set up Python
#         uses: actions/setup-python@v5
#         with:
#           python-version: '3.10'
#
#       # Python側でもRustコンパイラは必要
#       - name: Install Rust
#         uses: dtolnay/rust-toolchain@stable
#
#       - name: Install Maturin
#         run: pip install maturin
#
#       - name: Build and Test Python Module
#         # Releaseビルドでテストする場合、--release を追加してください
#         run: |
#           maturin develop --features python
#           python -c "import gs_slam_ccelerator; print(f'Test Result: {gs_slam_ccelerator.compute_metrics(1000, 1.0)}')"
</file>

<file path="www/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GS-SLAM Phase 3 Viewer</title>
    <style>
        body { margin: 0; background: #222; color: #eee; font-family: sans-serif; overflow: hidden; }
        canvas { width: 100%; height: 100vh; display: block; }
        #ui {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.8); padding: 15px; border-radius: 8px;
            display: flex; flex-direction: column; gap: 10px; pointer-events: none;
        }
        #ui > * { pointer-events: auto; }
        button { padding: 5px 10px; cursor: pointer; background: #444; color: white; border: 1px solid #666; }
        button:hover { background: #555; }
        button.active { background: #0077cc; border-color: #0099ff; }
        #status { font-size: 0.9em; color: #aaa; }
    </style>
</head>
<body>
    <div id="ui">
        <h3>GS-SLAM Viewer</h3>
        <div>
            <input type="file" id="fileInput" accept=".ply">
        </div>
        <div>
            <label>Mode:</label>
            <button id="btnRGB" class="active">RGB Color</button>
            <button id="btnNormal">Normal Map</button>
        </div>
        <div id="status">Waiting for PLY...</div>
        <div style="font-size: 0.8em; margin-top: 5px;">
            Left: Rotate | Right: Pan | Wheel: Zoom
        </div>
    </div>
    <canvas id="canvas"></canvas>
    
    <script type="module" src="./index.js"></script>
</body>
</html>
</file>

<file path="www/index.js">
import init, { WasmViewer } from './pkg/gs_slam_core.js';

async function run() {
    await init();
    console.log("WASM Initialized");

    const statusDiv = document.getElementById('status');
    const canvas = document.getElementById('canvas');
    const btnRGB = document.getElementById('btnRGB');
    const btnNormal = document.getElementById('btnNormal');

    // Resize Handling
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        if (window.viewer) window.viewer.resize(canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize);
    resize();

    try {
        const viewer = await WasmViewer.new("canvas");
        window.viewer = viewer; // Make global for resize event
        statusDiv.innerText = "Ready.";

        // Animation Loop
        function animate() {
            viewer.render();
            requestAnimationFrame(animate);
        }
        animate();

        // File Loading
        document.getElementById('fileInput').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            statusDiv.innerText = `Loading ${file.name}...`;
            try {
                const buffer = await file.arrayBuffer();
                const data = new Uint8Array(buffer);
                console.log(`Passing ${data.length} bytes to WASM`);
                viewer.load_data(data);
                statusDiv.innerText = `Rendering ${file.name} (${(data.length/1024/1024).toFixed(1)} MB)`;
            } catch (err) {
                console.error(err);
                statusDiv.innerText = "Error loading file";
            }
        });

        // Mode Switching
        btnRGB.onclick = () => {
            viewer.set_display_mode(0);
            btnRGB.classList.add('active');
            btnNormal.classList.remove('active');
        };
        btnNormal.onclick = () => {
            viewer.set_display_mode(1);
            btnRGB.classList.remove('active');
            btnNormal.classList.add('active');
        };

    } catch (e) {
        console.error("Initialization failed:", e);
        statusDiv.innerText = "WebGPU initialization failed. Check console.";
    }
}

run();
</file>

<file path="pyproject.toml">
[build-system]
requires = ["maturin>=1.0,<2.0"]
build-backend = "maturin"

[project]
name = "gs_slam_core"
requires-python = ">=3.8"
classifiers = [
    "Programming Language :: Rust",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]
dynamic = ["version"]
</file>

<file path="src/lib.rs">
use std::borrow::Cow;
use bytemuck::{Pod, Zeroable};
use wgpu::util::DeviceExt; // WGPUを使う箇所すべてで必要

// 行列計算: WASMでのみ使用（Python側ではGPU計算のみ行い、カメラ制御はしないため）
#[cfg(feature = "wasm")]
use nalgebra as na;

// ============================================================================
//  1. Data Structures (Shared)
// ============================================================================

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Pod, Zeroable)]
pub struct GaussianSplat {
    pub pos: [f32; 3],      // 0-12
    pub opacity: f32,       // 12-16
    pub scale: [f32; 3],    // 16-28
    pub _pad1: f32,         // 28-32
    pub rot: [f32; 4],      // 32-48
    pub sh_dc: [f32; 3],    // 48-60
    pub _pad2: f32,         // 60-64
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Pod, Zeroable)]
pub struct Surfel {
    pub pos: [f32; 3],      // 12
    pub color: [f32; 3],    // 12 (RGB from SH)
    pub normal: [f32; 3],   // 12
    pub _pad: [f32; 3],     // 12
}

// PLY読み込み用（全環境で必要）
#[repr(C, packed)]
#[derive(Copy, Clone, Debug, Default, Pod, Zeroable)]
struct RawSplat {
    x: f32, y: f32, z: f32,
    nx: f32, ny: f32, nz: f32,
    f_dc_0: f32, f_dc_1: f32, f_dc_2: f32,
    opacity: f32,
    scale_0: f32, scale_1: f32, scale_2: f32,
    rot_0: f32, rot_1: f32, rot_2: f32, rot_3: f32,
}

// ============================================================================
//  2. Core GPU Logic (Shared between Python & WASM logic if needed)
// ============================================================================

// Python向け: WGPUを使って計算シェーダーを走らせる関数
#[cfg(feature = "python")]
async fn run_compute_shader_headless(splats: &[GaussianSplat]) -> Vec<Surfel> {
    // 1. Instance
    let instance = wgpu::Instance::new(wgpu::InstanceDescriptor {
        backends: wgpu::Backends::all(),
        flags: wgpu::InstanceFlags::default(),
        dx12_shader_compiler: wgpu::Dx12Compiler::Fxc,
        gles_minor_version: wgpu::Gles3MinorVersion::Automatic,
    });

    // 2. Adapter
    let adapter = instance.request_adapter(&wgpu::RequestAdapterOptions {
        power_preference: wgpu::PowerPreference::HighPerformance,
        compatible_surface: None,
        force_fallback_adapter: false,
    }).await.expect("Failed to find GPU adapter");

    // 3. Device
    let (device, queue) = adapter.request_device(&wgpu::DeviceDescriptor {
        label: None,
        required_features: wgpu::Features::empty(),
        required_limits: wgpu::Limits::downlevel_defaults(),
        memory_hints: wgpu::MemoryHints::default(),
    }, None).await.expect("Failed to create device");

    // 4. Buffers
    let input_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("Input Buffer"),
        contents: bytemuck::cast_slice(splats),
        usage: wgpu::BufferUsages::STORAGE,
    });

    let output_size = (splats.len() * std::mem::size_of::<Surfel>()) as u64;
    let output_buffer = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("Output Buffer"),
        size: output_size,
        usage: wgpu::BufferUsages::STORAGE | wgpu::BufferUsages::COPY_SRC,
        mapped_at_creation: false,
    });
    
    let staging_buffer = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("Staging Buffer"),
        size: output_size,
        usage: wgpu::BufferUsages::MAP_READ | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });

    // 5. Pipeline
    let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("Shader"),
        source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(include_str!("shader.wgsl"))),
    });

    let bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: None,
        entries: &[
            wgpu::BindGroupLayoutEntry { binding: 0, visibility: wgpu::ShaderStages::COMPUTE, ty: wgpu::BindingType::Buffer { ty: wgpu::BufferBindingType::Storage { read_only: true }, has_dynamic_offset: false, min_binding_size: None }, count: None },
            wgpu::BindGroupLayoutEntry { binding: 1, visibility: wgpu::ShaderStages::COMPUTE, ty: wgpu::BindingType::Buffer { ty: wgpu::BufferBindingType::Storage { read_only: false }, has_dynamic_offset: false, min_binding_size: None }, count: None },
        ],
    });

    let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: None, bind_group_layouts: &[&bind_group_layout], push_constant_ranges: &[],
    });

    let pipeline = device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
        label: None, layout: Some(&pipeline_layout), module: &shader, entry_point: Some("compute_main"),
        compilation_options: Default::default(), cache: None,
    });

    let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: None, layout: &bind_group_layout,
        entries: &[
            wgpu::BindGroupEntry { binding: 0, resource: input_buffer.as_entire_binding() },
            wgpu::BindGroupEntry { binding: 1, resource: output_buffer.as_entire_binding() },
        ],
    });

    // 6. Execute
    let mut encoder = device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });
    {
        let mut cpass = encoder.begin_compute_pass(&wgpu::ComputePassDescriptor::default());
        cpass.set_pipeline(&pipeline);
        cpass.set_bind_group(0, &bind_group, &[]);
        let workgroups = (splats.len() as u32 + 63) / 64;
        cpass.dispatch_workgroups(workgroups, 1, 1);
    }
    encoder.copy_buffer_to_buffer(&output_buffer, 0, &staging_buffer, 0, output_size);
    queue.submit(Some(encoder.finish()));

    // 7. Readback
    let buffer_slice = staging_buffer.slice(..);
    let (sender, receiver) = futures_intrusive::channel::shared::oneshot_channel();
    buffer_slice.map_async(wgpu::MapMode::Read, move |v| sender.send(v).unwrap());
    device.poll(wgpu::Maintain::Wait);

    if let Some(Ok(())) = receiver.receive().await {
        let data = buffer_slice.get_mapped_range();
        let result: Vec<Surfel> = bytemuck::cast_slice(&data).to_vec();
        drop(data);
        staging_buffer.unmap();
        result
    } else {
        panic!("Failed to map buffer");
    }
}

// ============================================================================
//  3. Python Module (PyO3)
// ============================================================================

#[cfg(feature = "python")]
use pyo3::prelude::*;

#[cfg(feature = "python")]
#[pyclass]
struct SplatManager {
    splats: Vec<GaussianSplat>,
    surfels: Vec<Surfel>,
}

#[cfg(feature = "python")]
#[pymethods]
impl SplatManager {
    #[new]
    fn new(ply_path: String) -> PyResult<Self> {
        let path = std::path::Path::new(&ply_path);
        let file = std::fs::File::open(path).map_err(|e| pyo3::exceptions::PyFileNotFoundError::new_err(e.to_string()))?;
        let mmap = unsafe { memmap2::MmapOptions::new().map(&file).map_err(|e| pyo3::exceptions::PyIOError::new_err(e.to_string()))? };

        let header_end = b"end_header";
        let offset = mmap.windows(header_end.len())
            .position(|w| w == header_end)
            .map(|i| i + header_end.len())
            .ok_or_else(|| pyo3::exceptions::PyValueError::new_err("Invalid PLY header"))?;
        
        let mut cursor = offset;
        while cursor < mmap.len() && (mmap[cursor] == b'\r' || mmap[cursor] == b'\n') { cursor += 1; }
        
        let raw_data = &mmap[cursor..];
        let struct_size = std::mem::size_of::<RawSplat>();
        let count = raw_data.len() / struct_size;
        
        let raw_splats: &[RawSplat] = bytemuck::cast_slice(&raw_data[..count * struct_size]);
        let mut splats = Vec::with_capacity(count);

        for raw in raw_splats {
            splats.push(GaussianSplat {
                pos: [raw.x, raw.y, raw.z],
                opacity: raw.opacity,
                scale: [raw.scale_0, raw.scale_1, raw.scale_2],
                _pad1: 0.0,
                rot: [raw.rot_0, raw.rot_1, raw.rot_2, raw.rot_3],
                sh_dc: [raw.f_dc_0, raw.f_dc_1, raw.f_dc_2],
                _pad2: 0.0,
            });
        }
        
        Ok(SplatManager { splats, surfels: Vec::new() })
    }

    fn count(&self) -> usize {
        self.splats.len()
    }

    fn debug_first_splat(&self) -> PyResult<String> {
        if let Some(s) = self.splats.first() {
            Ok(format!("Pos: [{:.2}, {:.2}, {:.2}], Opacity: {:.2}", s.pos[0], s.pos[1], s.pos[2], s.opacity))
        } else {
            Ok("No data".into())
        }
    }

    fn compute_geometry(&mut self) -> PyResult<usize> {
        if self.splats.is_empty() { return Ok(0); }
        self.surfels = pollster::block_on(run_compute_shader_headless(&self.splats));
        Ok(self.surfels.len())
    }

    fn debug_first_surfel(&self) -> PyResult<String> {
        if let Some(s) = self.surfels.first() {
            Ok(format!(
                "Pos: [{:.2}, {:.2}, {:.2}], Color: [{:.2}, {:.2}, {:.2}], Normal: [{:.2}, {:.2}, {:.2}]",
                s.pos[0], s.pos[1], s.pos[2],
                s.color[0], s.color[1], s.color[2],
                s.normal[0], s.normal[1], s.normal[2]
            ))
        } else {
            Ok("No surfels computed".into())
        }
    }
}

#[cfg(feature = "python")]
#[pymodule]
fn gs_slam_core(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<SplatManager>()?;
    Ok(())
}

// ============================================================================
//  4. WASM Viewer (Interactive)
// ============================================================================

// カメラ制御用 (WASM専用)
#[cfg(feature = "wasm")]
struct CameraController {
    target: na::Point3<f32>,
    distance: f32,
    yaw: f32,
    pitch: f32,
    width: f32,
    height: f32,
}

#[cfg(feature = "wasm")]
impl CameraController {
    fn new(width: f32, height: f32) -> Self {
        Self {
            target: na::Point3::new(0.0, 0.0, 0.0),
            distance: 5.0,
            yaw: -std::f32::consts::FRAC_PI_2,
            pitch: 0.0,
            width,
            height,
        }
    }

    fn update_resolution(&mut self, width: f32, height: f32) {
        self.width = width;
        self.height = height;
    }

    fn rotate(&mut self, dx: f32, dy: f32) {
        self.yaw -= dx * 0.005;
        self.pitch -= dy * 0.005;
        self.pitch = self.pitch.clamp(-1.5, 1.5);
    }

    fn pan(&mut self, dx: f32, dy: f32) {
        let (view, _) = self.build_matrices();
        let right = na::Vector3::new(view[(0, 0)], view[(1, 0)], view[(2, 0)]);
        let up = na::Vector3::new(view[(0, 1)], view[(1, 1)], view[(2, 1)]);
        let pan_speed = self.distance * 0.001;
        self.target -= right * dx * pan_speed;
        self.target += up * dy * pan_speed;
    }

    fn zoom(&mut self, delta: f32) {
        self.distance -= delta * self.distance * 0.001;
        self.distance = self.distance.clamp(0.1, 100.0);
    }

    fn build_matrices(&self) -> (na::Matrix4<f32>, na::Matrix4<f32>) {
        let x = self.distance * self.yaw.cos() * self.pitch.cos();
        let y = self.distance * self.pitch.sin();
        let z = self.distance * self.yaw.sin() * self.pitch.cos();
        let eye = self.target + na::Vector3::new(x, y, z);
        let up = na::Vector3::y();

        let view = na::Matrix4::look_at_rh(&eye, &self.target, &up);
        let aspect = self.width / self.height;
        let proj = na::Matrix4::new_perspective(aspect, 45.0_f32.to_radians(), 0.1, 1000.0);
        (view, proj)
    }

    fn get_uniform(&self, mode: u32) -> [u8; 128] { // Return raw bytes directly for buffer
        let (view, proj) = self.build_matrices();
        #[rustfmt::skip]
        let opengl_to_wgpu = na::Matrix4::new(
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 0.5, 0.5,
            0.0, 0.0, 0.0, 1.0,
        );
        let view_proj = opengl_to_wgpu * proj * view;
        let vp_array: [[f32; 4]; 4] = view_proj.into();

        let x = self.distance * self.yaw.cos() * self.pitch.cos();
        let y = self.distance * self.pitch.sin();
        let z = self.distance * self.yaw.sin() * self.pitch.cos();
        
        let mut raw = [0u8; 128];
        // ViewProj (64 bytes)
        raw[0..64].copy_from_slice(bytemuck::cast_slice(&vp_array));
        // Camera Pos (12 bytes)
        let pos = [x, y, z];
        raw[64..76].copy_from_slice(bytemuck::cast_slice(&pos));
        // Mode (4 bytes, aligned at 80)
        let m = [mode];
        raw[80..84].copy_from_slice(bytemuck::cast_slice(&m));
        
        raw
    }
}

#[cfg(feature = "wasm")]
use wasm_bindgen::prelude::*;
#[cfg(feature = "wasm")]
use web_sys::{HtmlCanvasElement, MouseEvent, WheelEvent};
#[cfg(feature = "wasm")]
use std::rc::Rc;
#[cfg(feature = "wasm")]
use std::cell::RefCell;

#[cfg(feature = "wasm")]
#[wasm_bindgen]
pub struct WasmViewer {
    device: wgpu::Device,
    queue: wgpu::Queue,
    surface: wgpu::Surface<'static>,
    config: wgpu::SurfaceConfiguration,
    
    render_pipeline: wgpu::RenderPipeline,
    compute_pipeline: wgpu::ComputePipeline,
    
    bg_compute: Option<wgpu::BindGroup>,
    bg_render: Option<wgpu::BindGroup>,
    bgl_compute: wgpu::BindGroupLayout,
    bgl_render: wgpu::BindGroupLayout,

    uniform_buffer: wgpu::Buffer,
    vertex_buffer: Option<wgpu::Buffer>,
    num_vertices: u32,

    camera: Rc<RefCell<CameraController>>,
    display_mode: u32,
    
    _closures: Vec<wasm_bindgen::JsValue>,
}

#[cfg(feature = "wasm")]
#[wasm_bindgen]
impl WasmViewer {
    pub async fn new(canvas_id: &str) -> Result<WasmViewer, JsValue> {
        std::panic::set_hook(Box::new(console_error_panic_hook::hook));
        console_log::init_with_level(log::Level::Info).ok();

        let window = web_sys::window().unwrap();
        let document = window.document().unwrap();
        let canvas = document.get_element_by_id(canvas_id)
            .ok_or("Canvas not found")?
            .dyn_into::<HtmlCanvasElement>()?;

        let instance = wgpu::Instance::default();
        let surface = instance.create_surface(wgpu::SurfaceTarget::Canvas(canvas.clone()))
            .map_err(|e| e.to_string())?;
        
        let adapter = instance.request_adapter(&wgpu::RequestAdapterOptions {
            power_preference: wgpu::PowerPreference::HighPerformance,
            compatible_surface: Some(&surface),
            force_fallback_adapter: false,
        }).await.ok_or("No GPU adapter found")?;

        let (device, queue) = adapter.request_device(
            &wgpu::DeviceDescriptor {
                label: None,
                required_features: wgpu::Features::empty(),
                required_limits: wgpu::Limits::downlevel_webgl2_defaults(),
                memory_hints: wgpu::MemoryHints::default(),
            },
            None,
        ).await.map_err(|e| e.to_string())?;

        let width = canvas.width();
        let height = canvas.height();
        let config = surface.get_default_config(&adapter, width, height)
            .ok_or("Surface config failed")?;
        surface.configure(&device, &config);

        let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("Shader"),
            source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(include_str!("shader.wgsl"))),
        });

        // Compute Setup
        let bgl_compute = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Compute Layout"),
            entries: &[
                wgpu::BindGroupLayoutEntry { binding: 0, visibility: wgpu::ShaderStages::COMPUTE, ty: wgpu::BindingType::Buffer { ty: wgpu::BufferBindingType::Storage { read_only: true }, has_dynamic_offset: false, min_binding_size: None }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 1, visibility: wgpu::ShaderStages::COMPUTE, ty: wgpu::BindingType::Buffer { ty: wgpu::BufferBindingType::Storage { read_only: false }, has_dynamic_offset: false, min_binding_size: None }, count: None },
            ],
        });
        let pl_compute = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Compute PL"), bind_group_layouts: &[&bgl_compute], push_constant_ranges: &[],
        });
        let compute_pipeline = device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
            label: Some("Compute Pipeline"), layout: Some(&pl_compute), module: &shader, entry_point: Some("compute_main"),
            compilation_options: Default::default(), cache: None,
        });

        // Render Setup
        let uniform_buffer = device.create_buffer(&wgpu::BufferDescriptor {
            label: Some("Uniform Buffer"),
            size: 128,
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
            mapped_at_creation: false,
        });
        let bgl_render = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Render Layout"),
            entries: &[
                wgpu::BindGroupLayoutEntry { binding: 0, visibility: wgpu::ShaderStages::VERTEX, ty: wgpu::BindingType::Buffer { ty: wgpu::BufferBindingType::Uniform, has_dynamic_offset: false, min_binding_size: None }, count: None },
            ],
        });
        let pl_render = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Render PL"), bind_group_layouts: &[&bgl_render], push_constant_ranges: &[],
        });
        let render_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Render Pipeline"),
            layout: Some(&pl_render),
            vertex: wgpu::VertexState {
                module: &shader,
                entry_point: Some("vs_main"),
                buffers: &[wgpu::VertexBufferLayout {
                    array_stride: 48,
                    step_mode: wgpu::VertexStepMode::Vertex,
                    attributes: &[
                        wgpu::VertexAttribute { format: wgpu::VertexFormat::Float32x3, offset: 0, shader_location: 0 },
                        wgpu::VertexAttribute { format: wgpu::VertexFormat::Float32x3, offset: 12, shader_location: 1 },
                        wgpu::VertexAttribute { format: wgpu::VertexFormat::Float32x3, offset: 24, shader_location: 2 },
                    ],
                }],
                compilation_options: Default::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module: &shader,
                entry_point: Some("fs_main"),
                targets: &[Some(wgpu::ColorTargetState {
                    format: config.format, blend: Some(wgpu::BlendState::REPLACE), write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: Default::default(),
            }),
            primitive: wgpu::PrimitiveState { topology: wgpu::PrimitiveTopology::PointList, ..Default::default() },
            depth_stencil: None, multisample: Default::default(), multiview: None, cache: None,
        });

        let bg_render = Some(device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Render BG"), layout: &bgl_render, entries: &[
                wgpu::BindGroupEntry { binding: 0, resource: uniform_buffer.as_entire_binding() }
            ],
        }));

        // Interaction Setup
        let camera = Rc::new(RefCell::new(CameraController::new(width as f32, height as f32)));
        let mut closures = Vec::new();

        {
            let cam = camera.clone();
            let is_dragging = Rc::new(RefCell::new(false));
            let last_pos = Rc::new(RefCell::new((0.0, 0.0)));
            let drag_mode = Rc::new(RefCell::new(0));

            let c_drag = is_dragging.clone();
            let c_pos = last_pos.clone();
            let c_mode = drag_mode.clone();
            let closure = Closure::<dyn FnMut(_)>::new(move |e: MouseEvent| {
                *c_drag.borrow_mut() = true;
                *c_pos.borrow_mut() = (e.offset_x() as f32, e.offset_y() as f32);
                if e.button() == 2 { *c_mode.borrow_mut() = 2; } else { *c_mode.borrow_mut() = 1; }
            });
            canvas.add_event_listener_with_callback("mousedown", closure.as_ref().unchecked_ref()).unwrap();
            closures.push(closure.into_js_value());

            let c_drag = is_dragging.clone();
            let closure = Closure::<dyn FnMut(_)>::new(move |_: MouseEvent| {
                *c_drag.borrow_mut() = false;
            });
            window.add_event_listener_with_callback("mouseup", closure.as_ref().unchecked_ref()).unwrap();
            closures.push(closure.into_js_value());

            let closure = Closure::<dyn FnMut(_)>::new(move |e: MouseEvent| { e.prevent_default(); });
            canvas.add_event_listener_with_callback("contextmenu", closure.as_ref().unchecked_ref()).unwrap();
            closures.push(closure.into_js_value());

            let c_drag = is_dragging.clone();
            let c_pos = last_pos.clone();
            let c_mode = drag_mode.clone();
            let c_cam = cam.clone();
            let closure = Closure::<dyn FnMut(_)>::new(move |e: MouseEvent| {
                if *c_drag.borrow() {
                    let cx = e.offset_x() as f32;
                    let cy = e.offset_y() as f32;
                    let (lx, ly) = *c_pos.borrow();
                    let dx = cx - lx;
                    let dy = cy - ly;
                    if *c_mode.borrow() == 1 { c_cam.borrow_mut().rotate(dx, dy); }
                    else if *c_mode.borrow() == 2 { c_cam.borrow_mut().pan(dx, dy); }
                    *c_pos.borrow_mut() = (cx, cy);
                }
            });
            canvas.add_event_listener_with_callback("mousemove", closure.as_ref().unchecked_ref()).unwrap();
            closures.push(closure.into_js_value());

            let c_cam = cam.clone();
            let closure = Closure::<dyn FnMut(_)>::new(move |e: WheelEvent| {
                e.prevent_default();
                c_cam.borrow_mut().zoom(e.delta_y() as f32);
            });
            canvas.add_event_listener_with_callback("wheel", closure.as_ref().unchecked_ref()).unwrap();
            closures.push(closure.into_js_value());
        }

        Ok(Self {
            device, queue, surface, config,
            render_pipeline, compute_pipeline,
            bg_compute: None, bg_render,
            bgl_compute, bgl_render,
            uniform_buffer, vertex_buffer: None, num_vertices: 0,
            camera, display_mode: 0,
            _closures: closures,
        })
    }

    pub fn load_data(&mut self, data: &[u8]) {
        let header_end = b"end_header";
        let offset = data.windows(header_end.len())
            .position(|w| w == header_end)
            .map(|i| i + header_end.len());
        
        if let Some(mut cursor) = offset {
            while cursor < data.len() && (data[cursor] == b'\r' || data[cursor] == b'\n') { cursor += 1; }
            let raw_data = &data[cursor..];
            let struct_size = std::mem::size_of::<RawSplat>();
            let count = raw_data.len() / struct_size;
            
            if count == 0 { return; }
            log::info!("Loading {} splats...", count);

            let raw_splats: &[RawSplat] = bytemuck::cast_slice(&raw_data[..count * struct_size]);
            let mut splats = Vec::with_capacity(count);
            for raw in raw_splats {
                splats.push(GaussianSplat {
                    pos: [raw.x, raw.y, raw.z],
                    opacity: raw.opacity,
                    scale: [raw.scale_0, raw.scale_1, raw.scale_2],
                    _pad1: 0.0,
                    rot: [raw.rot_0, raw.rot_1, raw.rot_2, raw.rot_3],
                    sh_dc: [raw.f_dc_0, raw.f_dc_1, raw.f_dc_2],
                    _pad2: 0.0,
                });
            }

            let input_buf = self.device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
                label: Some("Input"), contents: bytemuck::cast_slice(&splats), usage: wgpu::BufferUsages::STORAGE,
            });
            let output_size = (count * std::mem::size_of::<Surfel>()) as u64;
            let output_buf = self.device.create_buffer(&wgpu::BufferDescriptor {
                label: Some("Output"), size: output_size, usage: wgpu::BufferUsages::STORAGE | wgpu::BufferUsages::VERTEX, mapped_at_creation: false
            });

            let bg_compute = self.device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Compute BG"), layout: &self.bgl_compute,
                entries: &[
                    wgpu::BindGroupEntry { binding: 0, resource: input_buf.as_entire_binding() },
                    wgpu::BindGroupEntry { binding: 1, resource: output_buf.as_entire_binding() },
                ],
            });

            let mut encoder = self.device.create_command_encoder(&wgpu::CommandEncoderDescriptor::default());
            {
                let mut pass = encoder.begin_compute_pass(&wgpu::ComputePassDescriptor::default());
                pass.set_pipeline(&self.compute_pipeline);
                pass.set_bind_group(0, &bg_compute, &[]);
                pass.dispatch_workgroups((count as u32 + 63) / 64, 1, 1);
            }
            self.queue.submit(Some(encoder.finish()));

            self.vertex_buffer = Some(output_buf);
            self.num_vertices = count as u32;
            self.bg_compute = Some(bg_compute);
            log::info!("GPU Data Ready.");
        }
    }

    pub fn set_display_mode(&mut self, mode: u32) {
        self.display_mode = mode;
    }

    pub fn resize(&mut self, width: u32, height: u32) {
        if width > 0 && height > 0 {
            self.config.width = width;
            self.config.height = height;
            self.surface.configure(&self.device, &self.config);
            self.camera.borrow_mut().update_resolution(width as f32, height as f32);
        }
    }

    pub fn render(&mut self) {
        let output = match self.surface.get_current_texture() {
            Ok(tex) => tex,
            Err(_) => return,
        };
        let view = output.texture.create_view(&wgpu::TextureViewDescriptor::default());
        
        let raw_uniform = self.camera.borrow().get_uniform(self.display_mode);
        self.queue.write_buffer(&self.uniform_buffer, 0, &raw_uniform);

        let mut encoder = self.device.create_command_encoder(&wgpu::CommandEncoderDescriptor::default());
        {
            let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                label: None,
                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                    view: &view, resolve_target: None,
                    ops: wgpu::Operations { load: wgpu::LoadOp::Clear(wgpu::Color::BLACK), store: wgpu::StoreOp::Store },
                })],
                depth_stencil_attachment: None, timestamp_writes: None, occlusion_query_set: None,
            });

            if let Some(vb) = &self.vertex_buffer {
                pass.set_pipeline(&self.render_pipeline);
                if let Some(bg) = &self.bg_render { pass.set_bind_group(0, bg, &[]); }
                pass.set_vertex_buffer(0, vb.slice(..));
                pass.draw(0..self.num_vertices, 0..1);
            }
        }
        self.queue.submit(Some(encoder.finish()));
        output.present();
    }
}
</file>

<file path="Cargo.toml">
[package]
name = "gs_slam_core"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

# === 機能フラグ (重要: nalgebra をここに追加) ===
[features]
default = ["python"]
python = ["dep:pyo3", "dep:memmap2", "dep:nalgebra"]
wasm = ["dep:wasm-bindgen", "dep:wasm-bindgen-futures", "dep:web-sys", "dep:console_error_panic_hook", "dep:console_log", "dep:log", "dep:nalgebra"]

# === 依存関係 ===
[dependencies]
# wgpuは全環境で使う
wgpu = { version = "23.0" }
bytemuck = { version = "1.16", features = ["derive"] }
pollster = "0.3"
futures-intrusive = "0.5"

# 数学ライブラリ (重要: optional = true にして機能フラグで管理)
nalgebra = { version = "0.32", optional = true }

# === Python専用 ===
pyo3 = { version = "0.23", features = ["extension-module"], optional = true }
memmap2 = { version = "0.9", optional = true }

# === WASM専用 ===
wasm-bindgen = { version = "0.2", optional = true }
wasm-bindgen-futures = { version = "0.4", optional = true }
console_error_panic_hook = { version = "0.1", optional = true }
console_log = { version = "1.0", optional = true }
log = { version = "0.4", optional = true }

[dependencies.web-sys]
version = "0.3"
features = [
    "Document",
    "Window",
    "HtmlCanvasElement",
    "Element",
    "Location",
    "MouseEvent",   # <--- これがないとエラーになる
    "WheelEvent",   # <--- これがないとエラーになる
    "HtmlInputElement",
    "FileList",
    "File",
    "Blob"
]
optional = true

[profile.release]
lto = "fat"
codegen-units = 1
opt-level = 3
</file>

</files>
